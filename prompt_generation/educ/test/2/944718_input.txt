((-1, 944718)) => <div class="ttypography"><p>I'm confused. In D1 Wouldn't i-256 also work, since it toggles the 9'th bit (which cannot be toggled by any number in the array).</p></div>
((944718, 944734)) => <div class="ttypography"><p>I think it does, but 500 works as well and might be easier to see why.</p></div>
((944718, 944821)) => <div class="ttypography"><p>i tought &quot;xor 200 will add or subtract at most 200&quot;. So i went with 402 just to be sure. It feels like the most intuitive lower bound to me, but i didn't think about it too much</p></div>
((944718, 944879)) => <div class="ttypography"><p>The best bound I could think of is i-2*max+1 (and it does not need to be the maximum of the entire array, just of the elements before and including the current one, from 0 to i): </p><p>If j &lt; i-2*max+1, then j &lt;= i-2*max and j^ai &lt;= i-max &lt;= i^aj. So, if j &lt; i-2*max+1 we do not need to check this j.</p><p>But maybe this is not the best possible bound: I just manually binary-searched the problem and i-255 is accepted, i-254 is not.</p></div>
((944718, 944888)) => <div class="ttypography"><p>This is correct. Technically, $$$i - 256$$$ and below are guaranteed to fail the condition (since the prefix before the last 8 bits cannot be XOR'd out), so you can start checking from $$$i - 255$$$ onwards. </p></div>
((944888, 945011)) => <div class="ttypography"><p>In fact, you can do something more interesting â€” simply tile n in sections of 256 and solve each section separately.</p><p> <submission link> </p></div>
