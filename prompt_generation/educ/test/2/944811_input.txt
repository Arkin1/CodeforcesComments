((-1, 944811)) => <div class="ttypography"><p>can anyone explain why we dont have to go beyond 256 for checking for a particular i... i am not able to get this by editorial </p></div>
((944811, 944825)) => <div class="ttypography"><p>It's because when xoring a[i] with j, you will get j modified by maximum 8 bits (because a[i] &lt;= 200), therefore you need to check only the last 256 to make it bigger than a[i] ^ j</p></div>
((944825, 945198)) => <div class="ttypography"><p>I'm sorry, but I didn't get you, could you explain a bit further?</p><p>We have known that because $$$a[i],a[j]\leq 200$$$, so that utmost changes of j and i is 256. However, as j added 256 and i decreased 256, the gap between j and i was 512 in total.</p><p>The editorial said the it was correct as well despite you started j from i-256, which is beyond my comprehension. Could you please explain why, if in your comfort?</p></div>
((945198, 945200)) => <div class="ttypography"><p>You have to see it as binary representation to understand it better.</p><p>You are now at position j, a[i] ^ j is gonna range between j and j — 256, because only the first 8 bits can change. Now you have to find this is i that satisfies the property that a[j] ^ i is bigger than a[i] ^ j. Because of what I said earlier, to achieve that the only posibilities of i are between j and j — 256.</p></div>
((945200, 945233)) => <div class="ttypography"><p>Thanks for your reply.</p></div>
((945233, 945235)) => <div class="ttypography"><p>Did it help you at least?</p></div>
((945235, 945260)) => <div class="ttypography"><p>Could you explain it a bit more ?</p></div>
((945260, 945262)) => <div class="ttypography"><p>What exactly?</p></div>
((945262, 945263)) => <div class="ttypography"><p>a[j]⊕i changes i not more than by 200. This part in the editorial</p></div>
((945263, 945267)) => <div class="ttypography"><p><em>visualize in binary to understand better</em> </p><p>when xoring, all that matters are the set bits (1)</p><p>because you have a[i] &lt;= 200 =&gt; a[i] can have 8 set bits (from 0th to 7th)</p><p>so when you are xoring i with a[j], only the last 8 bits change in the binary represation of i, if you convert those possible outcomes in base 10, you get a maxmum of 256</p></div>
((945235, 945354)) => <div class="ttypography"><p>Of course. Thank you for your timely comment（and sorry for the time gap）！</p><p>However, what I really want to know is the following. In your clarification, you have explained a[i] ^ j is in range(j-256, j), and you concluded that thus &quot; that the only posibilities of i are between j and j — 256&quot;，but what about the i? a[j] ^ i makes it possible that i may increase 256 as well.(An obvious property is that $$$a-b \leq a \bigoplus b \leq a+b$$$), Then the maximum gap between a[i]^j and a[j]^i may be 512 instead of 256. The editorial said &quot;it's not hard that we could prove j from i-256&quot;(note that i and j have different meanings in your explanation and the editorial), which really confused me.</p><p>Thank you again for making such timely explanation and I'm looking forward to your further comments! :)</p></div>
((945354, 945398)) => <div class="ttypography"><p>Because you are doing a[i] ^ j that is the boundary, because you habe to make a[i] ^ j &lt; a[j] ^ i, because of that, the range of i is between j, j — 256 (the same observation applies here)</p></div>
((945398, 945419)) => <div class="ttypography"><p>Get it. Thank you~</p></div>
((945419, 945451)) => <div class="ttypography"><p><a class="rated-user user-cyan" href="/profile/skytyf" title="Specialist skytyf">skytyf</a> Can you explain it to me why it's not 512? how are we reaching 256?</p></div>
((945451, 945845)) => <div class="ttypography"><p>I believed <a class="rated-user user-blue" href="/profile/Sochu" title="Expert Sochu">Sochu</a>'s clarification is one of the proof. To me, I understood it in this way:</p><p>（Please copy it into notepad to read more comfortably） If the gap between i and j is over 256, the last 9th digit of i and j in binary representation is bound to change by at least 1.(That is, the pattern of i and j in binary representation is like (1..M********)_2 and (1..(M-1)********)_2 [Of course we didn't consider the M=0 case because the reason is the same and '*' can be 0 or 1 arbitrarily] )</p><p><strong>emphasis:We want to find a[j] ^ i &lt; a[i] ^ j (when j&lt;i)</strong> Suppose the case I raised above, why we didn't take the 512 into account?Let us consider why (i-512, i-257) definitely don't fit in the case. Due to the reason above, j in this range have the last 9th digit different from the i(or maybe 10th, 11th...), and a[i] &lt;= 200, which is only have a (********)_2 format. And after a[j]^i a[i]^j，the last 9th digit didn't change, and then we reach that a[i] ^ j still less than a[j] ^ i(Because 9th digit is less), which didn't meet our condition.</p><p>So we just have to start j from i-256</p></div>
