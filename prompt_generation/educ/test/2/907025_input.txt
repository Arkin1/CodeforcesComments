((-1, 907025)) <<===>> In A it is said that (ans = false) if s[i] != s[i+1]. But what if in test 1, aaaabbb, when it runs from a to b (aaaABbb) it's false and it cout "NO" ?, I think I'm understanding it wrong, can someone pls help [<<<new_com>>>]
((907025, 907323)) <<===>>  if (s[i] != s[i+1] and s[i] != s[i-1]) ans = false  It's also better to draw 1 upper-case character to understand this better. So when you're in "aaaAbbb" you check if(a != b and a != a) => if(true and false) => if(false) So the answer doesn't become "NO". You don't enter the if statement and the answer remains "YES". Remember, when you have statements separated by "and" operators, all of them need to be true for the whole statement to be true. I think if you put some more thought into it you will get it. In case this implementation confuses you:  for j in range(n): if (j == 0 or s[j] != s[j — 1]) and (j == n — 1 or s[j] != s[j + 1]): ans = False  keep in mind that "j == 0" and "j == n-1" statements only help for the extreme cases. In our example, for "Aaaabbb" and "aaaabbB". In those special cases we only check one neighbour. [<<<new_com>>>]
((907323, 907385)) <<===>> thanks ! [<<<new_com>>>]
