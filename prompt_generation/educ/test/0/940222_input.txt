((-1, 940222)) <<===>> Question on problem D. There is an approach that calculates the same as in the editorial, but in a slightly different way, and gets WA. The solution is the following: let's calculate $$$dp_i,_j$$$ â€” the number of ways to achieve $$$i$$$ using $$$j$$$ steps. $$$dp_0,_0 = 1$$$. Transition is presented in full form and can be calculated faster. $$$dp_i,_j$$$ = $$$\sum_{w=1, q=k+j-1}^{i - wq >= 0} dp_{i - wq},_{j - 1}$$$ What is the difference between calculated $$$dp_i,_j$$$ from the solution described above and calculated $$$dp_s,_i$$$ from the editorial? [<<<new_com>>>]
((940222, 940272)) <<===>> I'm a little confused by the expression, since it has a single summation controlled by two variables, so do you mean that we try every possible combination of $$$w$$$ and $$$q$$$ that satisfies $$$w \geq 1$$$, $$$q \geq k + j - 1$$$, and $$$i - wq \geq 0$$$?  I think a simple counterexample is $$$dp_{3, 1}$$$ for $$$k = 2$$$ (the third entry in the sample output 2 of the problem). Your formula would include $$$dp_{0, 0} = 1$$$ ($$$w = 1$$$, $$$q = 3$$$) in the summation, but the actual value of $$$dp_{3, 1}$$$ is $$$0$$$. My guess is that your approach allows skipping steps, e.g., it allows you to take a step of size $$$(k + i + 1)$$$ without taking a step of size $$$(k + i)$$$. The problem requires that you must take at least one step for each value between $$$k$$$ and the largest step size inclusive.  [<<<new_com>>>]
((940272, 940368)) <<===>> I think what they mean by the 2 variables is that, $$$q$$$ is the constant denoting the number whose multiple was the last step length, i.e, $$$q = k + (j - 1)$$$ and $$$w$$$ varies freely. Hence for $$$dp[3][1]$$$, $$$q$$$ can't be 3. Romiros : Your approach is correct (and is in fact the same as the editorial solution, except that your DP takes contribution from old states, while the editorial's solution provides contribution to new states). You have 2 small bugs in your implementation though. You can take a look at Ticket 15995 from CF Stress for a counter example.  Hints for Bug 1There are 2 possible ways to reach 12 for the given counter example. $$$(0 \rightarrow 12)$$$ and $$$(0 \rightarrow 3 \rightarrow 7 \rightarrow 12)$$$. Try to print the entire DP table and take a look at entries $$$dp[12][3]$$$ and $$$dp[7][2]$$$ and $$$dp[3][1]$$$. Hints for Bug 2:Your precompute a safe limit for $$$cnt$$$ by iterating with the smallest steps. You even multiply it by 3 to handle off by one errors. However, your current implementation results in a value of $$$cnt$$$ that is way smaller than the correct count that should be used. [<<<new_com>>>]
((940368, 940388)) <<===>> Got it, thanks. But why are $$$cnt$$$ steps not enough? [<<<new_com>>>]
((940388, 940391)) <<===>> $$$sum1 += K$$$ implies that the step length is $$$K$$$. Therefore, $$$K$$$ should be overwritten with $$$k+1$$$ at each stage. However, $$$K + = k + cnt$$$ makes it increment by that amount instead of overwriting it.  [<<<new_com>>>]
((940391, 940410)) <<===>> Oh, my bad, thanks again. [<<<new_com>>>]
((940391, 946861)) <<===>> Thanks a lot  [<<<new_com>>>]
((940272, 940381)) <<===>> Summation controlled only by variable $$$w$$$ and continues until $$$i - wq >= 0$$$, $$$wq$$$ is length of the move on $$$j$$$-th step, $$$q$$$ is the number that should divide length of the move on $$$j$$$-th step. The solution passes pretests and gets WA3. Somehow it counts fewer number of ways than needed. [<<<new_com>>>]
((940381, 949750)) <<===>> i have the same question.i get WA3 in a slightly difference than the std.i set the max step sqrt(n)+10.is it enough? [<<<new_com>>>]
((940381, 949751)) <<===>> ohhh.I know.it's not enough!max step should be calculated.can't be set sqrt(n) [<<<new_com>>>]
