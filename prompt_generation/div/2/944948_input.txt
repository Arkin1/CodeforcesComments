((-1, 944948)) <<===>> Can someone explain D2 to me like I'm stupid? Because I couldn't quite understand the editorial after storing the answer in a bit trie and also because I pretty much am [<<<new_com>>>]
((944948, 944972)) <<===>> We can build the longest subsequence iteratively by sweeping from $$$0$$$ to $$$n$$$ and finding the longest subsequence so far that our current index(lets call it $$$i$$$) can add on to. Naively, this is $$$dp$$$ solution is $$$O(n^2)$$$. The main intuition behind the speedup to this problem is that, when comparing two numbers $$$a$$$ and $$$b$$$ in their binary representation, the only important digit $$$k$$$ is the first digit where they differ. Conveniently, there are only 30 possible values of $$$k$$$. This motivates us to use a binary trie that stores prefixes, and for each prefix we can keep track of the maximum $$$dp$$$ value where some bitstring with said prefix exists. However, how do we know if for some digit $$$k$$$, the required configuration of $$$j$$$ and $$$a_j$$$ such that we satisfy the inequality $$$a_j \oplus i < a_i \oplus j$$$? Let's do some casework and see if that simplifies anything. Case 1: $$$k$$$ is off in both $$$i$$$ and $$$a_i$$$. In this case, to satisfy the inequality, we want the kth bit to be set in $$$a_i \oplus j$$$ but not $$$a_j \oplus i$$$, so the kth bit should be set in $$$j$$$ but not in $$$a_j$$$. We can then update $$$dp_i$$$ accordingly. To figure out which subtree of the trie we should descend to, note that the prefixes of $$$a_j \oplus i$$$ and $$$a_i \oplus j$$$ should remain identical, so we want the status of $$$k$$$ in $$$a_j$$$ and $$$j$$$ to be the same. This raises a little bit of a problem, since this is two subtrees that we must visit. For now, lets look at the other cases.Case 2: $$$k$$$ is off in $$$i$$$ but on in $$$a_i$$$:In this case, to satisfy the inequality, $$$k$$$ should be off in both bits. The subtrees that we must descend to (so we can find answers where the differing digit between $$$a_j \oplus i$$$ and $$$a_i \oplus j$$$ is greater than k) are those where $$$k$$$ is on in one of $$$j$$$ or $$$a_j$$$ but off in the other.Case 3: $$$k$$$ is on in $$$i$$$ but off in $$$a_i$$$: Here, to satisfy the inequality, we want the kth bit to be on in both bits. The subtrees that we should descend to are those where the $$$k$$$ bits differ.Case 4: $$$k$$$ is on in both bits. And lastly, for this case, the kth bit should be on in $$$a_j$$$ but off in $$$j$$$. The subtrees that we should descend to are the ones where the kth bits are the same.We can notice one major observation so that we only visit one subtree, instead of $$$2$$$: only the value of $$$a_j \oplus j$$$ matters, since we wish to make the prefixes indentical. However, then there is the final question of, for the subtree that we don't visit, how do we know if the maximum $$$dp$$$ value is valid? For example, if we are on the kth bit where it is off in both $$$i$$$ and $$$a_i$$$, the maximal $$$dp$$$ value may have some configuration where the kth bit is on in $$$a_j$$$ and not $$$j$$$. This will obviously cause $$$a_j \oplus i$$$ to be greater than $$$a_i \oplus j$$$. Well, thankfully, there are only 2 possible configurations for such a subtree where $$$a_j$$$ and $$$j$$$ differ in their kth bit: either $$$a_j$$$ has the kth bit set and $$$j$$$ doesn't, or $$$j$$$ has the kth bit set and $$$a_j$$$ doesn't. Similarly, for the subtree where $$$j$$$ and $$$a_j$$$ have the same status for their kth bit, there are only two cases: either it is set in both or off in both. So we can keep track of such $$$dp$$$ values separately.So, our trie nodes only need to know: The child where the next bit is indentical in $$$a_j \oplus j$$$, the child where the kth bit differs, and the maximum dp values for the case where the kth bit is on in $$$j$$$, and the case where the kth bit is off.When we are finished processing $$$i$$$, all we have to do is insert it into the trie and update the max $$$dp$$$ values accordingly. Then we can move on to $$$i+1$$$. The answer should obviously be the max value of $$$dp_i$$$ for all $$$i$$$.  [<<<new_com>>>]
((944948, 944979)) <<===>> Our goal will be to calculate $$$dp[i]$$$, which is the longest valid subsequence starting at index $$$i$$$. We will calculate $$$dp[i]$$$ in decreasing order of $$$i$$$. In addition, we will maintain a trie which somehow stores elements of the array / $$$dp$$$ values. The flow of our solution would be something like:a) For $$$0 \le i \le n - 1$$$: (decreasing)a1) Calculate $$$dp[i]$$$ based on previous $$$dp$$$ values, using our trie.a2) Insert the $$$i$$$'th element to the trie, somehow.The $$$O(n^2)$$$ $$$dp$$$ formula is something like: $$$dp[i] = max_{j > i, a[i] \oplus j < a[j] \oplus i}(dp[j] + 1)$$$. Therefore, we want to insert the elements into the trie in such a way that retrieving the maximal $$$dp[j]$$$ for all $$$j$$$ such that $$$a[i] \oplus j < a[j] \oplus i$$$ is easy.Recall that comparing two binary numbers can be done lexicographically. Assume that up to the $$$k$$$'th leftmost bit, the two expressions are equal. Then, LHS will be smaller than RHS for some $$$(j, a[j])$$$ if and only if one of two happens:  $$$(a[i] \oplus j)_{k} = 0$$$ and $$$(a[j] \oplus i)_{k} = 1$$$. $$$(a[i] \oplus j)_{k} = (a[j] \oplus i)_{k}$$$, and in a later bit, 1 happens. The first condition is equivalent to $$$(a[i] \oplus i)_{k} \neq (a[j] \oplus j)_{k}$$$ and $$$a[j]_{k} \neq i_{k}$$$. The second condition is equivalent to $$$(a[i] \oplus i)_{k} = (a[j] \oplus j)_{k}$$$, and in a later bit, 1 happens. We can already start to see that it might be worth it to save $$$a[j] \oplus j$$$ values. These are exactly the values we will insert into the trie at step a2). It is only left to figure out how to perform step a1). We will traverse the trie bit-by-bit. For the $$$k$$$'th bit, we will  (Condition 1) Check the maximal $$$dp$$$ value among all $$$j$$$ s such that $$$(a[i] \oplus i)_{k} \neq (a[j] \oplus j)_{k}$$$ (easy — this is how we store the trie), and $$$a[j]_{k} \neq i_{k}$$$ (also easy — for each trie node we will also store the maximal $$$dp$$$ value for $$$a[j]_{k} = 0$$$ and for $$$a[j]_{k} = 1$$$). (Condition 2) Traverse to the subtree of $$$(a[i] \oplus i)_{k} = (a[j] \oplus j)_{k}$$$, and recursively continue. If we maintain these values, we will get $$$O(n \cdot log(C))$$$ total complexity, and total trie nodes. [<<<new_com>>>]
((944979, 945092)) <<===>> Why is it sufficient to check only for the first $$$k_{th}$$$ different bit in our trie and no not see further down the trie for the condition $$$(j > i), (a[i] \oplus j) < (a[j] \oplus i)$$$ to be true, as the value of successive bit increases as we go down the trie example : $$$2^{k+2} > 2^{k}$$$, for some bit k+2 and k. $$$\newline$$$ Or like can you help me in understanding how does $$$a[i] \oplus i$$$ helps in finding $$$j$$$ for our original inequality $$$(a[i] \oplus j) < (a[j] \oplus i)$$$ to satisfy. $$$\newline$$$ [<<<new_com>>>]
((945092, 945156)) <<===>> We're going from MSB to LSB (Values are inserted MSB first). So we know which expression is bigger on the first such bit which is different. [<<<new_com>>>]
((945156, 945511)) <<===>> Thank You! [<<<new_com>>>]
((944979, 945104)) <<===>> 1.) Can u explain  (code) ? It seems if  (code) , it will fail. 2.) Also, can u explain in detail how to calculate this using dp?I think either it should be  (code)  or  (code)  [<<<new_com>>>]
((945104, 945159)) <<===>>  This is because if $$$a[j]_{k} \neq i_{k}$$$, it necessarily means that $$$a[j]_{k} \oplus i_{k} = 1$$$, which is what we want (this also implies that $$$a[i]_{k} = j_{k}$$$, or equivalently $$$a[i]_{k} \oplus j_{k} = 0$$$ For each trie node we save two values: $$$max_0, max_1$$$. $$$max_i$$$ is the maximal $$$dp$$$ value in the subtree of that node, amongst all $$$j$$$ s such that $$$a[j]_{k} = i$$$. Best way to go with it is an example: Initialize $$$bestSoFar = 0$$$. Suppose we're at the $$$k$$$th bit, and $$$a[i]_{k} = 1, i_{k} = 0$$$. For condition (1) to hold, we need $$$j_{k} = 1, a[j]_{k} = 1$$$ which is equivalent to $$$a[j]_{k} \oplus j_{k} = 0$$$ and $$$a[j]_{k} = 1$$$. From the current trie node, check its child that has $$$a[j]_{k} \oplus j_{k} = 0$$$, and update $$$bestSoFar$$$ accordingly ($$$bestSoFar = max(bestSoFar, max_1)$$$). Then, go to the other child (with $$$a[j]_{k} \oplus j_{k} = 1$$$) and continue recursively.  AlsoOliviera better [<<<new_com>>>]
((945159, 945189)) <<===>> Yeah understood. In my case I assumed  (code)  Thnx for the explanation [<<<new_com>>>]
((945159, 945192)) <<===>> Going back to problem statement. It says  (code) . Does it not mean we need to find single closest pair of (i, j) matching that condition and we are done? [<<<new_com>>>]
((944979, 945240)) <<===>> Omer223 & omeganot Thank you guys ur awesome ❤️ [<<<new_com>>>]
