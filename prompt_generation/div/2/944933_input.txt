((-1, 944933)) => <div class="ttypography"><p>For $$$D2$$$, what I got from the editorial is that for each $$$i$$$ from $$$0$$$ to $$$n-1$$$ we will calculate $$$dp[i]$$$ which is the maximum size of a valid subset ending at $$$i$$$, then insert it into the trie by descending with value $$$a[i]\oplus i$$$.</p><p>My question is: While we are descending the trie to calculate $$$dp[i]$$$, if the $$$k^{th}$$$ bit is $$$0$$$ in $$$a[i]\oplus i$$$, we will descend in the left subtree but before that we want to know the best possible answer in the right subtree. So, we actually want the maximum value in the right subtree which corresponds to $$$j$$$ whose $$$k^{th}$$$ bit has a specific value (which will make $$$a[j]\oplus i &lt; a[i]\oplus j$$$). How can we do this part?</p></div>
((944933, 944938)) => <div class="ttypography"><p>note that since the prefix of the bitstrings of $$$a_i \oplus i$$$ and every other string in this specific subtree of the trie must be identical. as such, the kth bit should be the first one to differ. We also know that this bit is identical in $$$i$$$ and $$$a_i$$$(because $$$i \oplus a_i = 0$$$). So, if it is on in both we want a $$$j$$$ such that the kth bit is on in $$$a_j$$$(since this is the other subtree of the trie where $$$a_j \oplus j = 1$$$, this means that the kth bit is off in $$$j$$$ by default). Otherwise, if it is off in both then we want the kth bit in $$$a_j$$$ to be off. Similar casework can be done for all other configurations of $$$i$$$ and $$$a_i$$$. As such, for each node in the trie, we can keep track of the max $$$dp$$$ value where the kth bit in $$$a_j$$$ is on, and the max $$$dp$$$ value where the bit is off separately. </p></div>
((944938, 944940)) => <div class="ttypography"><p>'We also know that this bit is identical in i and ai(because iâŠ•ai=0)' Can you explain how?</p></div>
((944940, 944947)) => <div class="ttypography"><p>It's because the original question proposed travelling to the left subtree as an example for that bit</p></div>
((944933, 944945)) => <div class="ttypography"><p>Suppose all the element idxs in the subtree you don't descend are {j1, ...}. If you are on the kth bit, you know for sure that the previous bits are equal, so the only important bit is the kth. </p><p>So you only need to save the max dp for j's with kth bit equal to 0, and another for j's with kth bit equal to 1</p><p>If kth bit of a[i] is 1, you'll need the answer for j with kth bit 0. If kth bit of a[i] is 0, you'll need the answer for j with kth bit 1.</p></div>
((944933, 944959)) => <div class="ttypography"><p>Thanks all for your insights, they are appreciated.</p></div>
