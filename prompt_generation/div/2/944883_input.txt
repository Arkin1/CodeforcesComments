((-1, 944883)) <<===>> I do not understand the solution to D2. Are we solving for each prefix in order ? Is i the index of the last element of the prefix ? Is j the index of the element before it ? Are the k bits the k most significant bits or least significant bits ? Are the "answers" the length of the subsequences for each prefix ? [<<<new_com>>>]
((944883, 944935)) <<===>> I have the same questions. The editorial is quite unclear and has some grammatically wrong sentences that are hard to comprehend. Please, in case you finally understand how to solve D2, share an explanation [<<<new_com>>>]
((944935, 944939)) <<===>> I'm working on it. I would recommend to check -is-this-fft-'s submission. [<<<new_com>>>]
((944883, 944946)) <<===>> Basically you are solving like the dp brute force. Because of the fact that a[i] ^ i has the same prefix of a[j] ^ j, you are trying to track it with a trie. Now if you traversed k bits, the k + 1'th bit should satisfy the property. Because of that you need to keep track in the trie the maximum answer which has the prefix of a[i] ^ i, between of all possible js, that has the k + 1 th bit of j and k + 1 th bit a[j]Check my submission:  (link to problem D2)  [<<<new_com>>>]
((944946, 944955)) <<===>> Thanks for taking the time to explain !I still do not understand, why would a[i]^i and a[j]^j have the same prefix ? What are those bits that we are traversing ? Which property are you talking about ? [<<<new_com>>>]
((944955, 944956)) <<===>> There is a prefix which is equal in a[i] ^ j , and a[j] ^ i, now think of that prefix as a number: (imagine now that you have only the common prefix) a[i] ^ j = a[j] ^ i, xor it with j => a[i] = a[j] ^ j ^ i, xor it wity i => a[i] ^ i = a[j] ^ jWe are traversing the bits of a[i] ^ i, the only thing that remains is to satisfy the property, by tracking what I explained last [<<<new_com>>>]
((944883, 944980)) <<===>> See my comment below, I explained it in more detail (Also the guy above my comment explained it well) [<<<new_com>>>]
