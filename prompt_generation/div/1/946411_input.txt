((-1, 946411)) <<===>> "If there is at least one operation left, there are two cases: k=1 and k>=2.If the first case, it is optimal to apply our operation near one of the maximums in the array to maximize min(a_i,a_{i+1})"Would it not be more optimal to change a_i > = ans/2 to 1e9? Consider ans = 18, and the following array-[0,1,4,5,6,9,10,11,15,17] and nodes [1,2,3,4,5,6,7,8,9,10]Let k = 6. The binary search solution would turn this to-[1e9, 1e9, 1e9, 1e9, 1e9, 9, 10, 11, 15, 17] and k = 1.Now, if we change 15 to 1e9 (as mentioned in the solution), then d(9,10) = 2*9 = 18. But if we change 9 to 1e9, then d(6,8) = 2*10 = 20 > 18? [<<<new_com>>>]
((946411, 946412)) <<===>> I meant $$$k = 1$$$ and $$$k \ge 2$$$ for the value initially given, not after we apply the operation some number of times. [<<<new_com>>>]
((946412, 946416)) <<===>> I am not sure I follow, consider-arr = [2,3,4,5,11,12], nodes = [1,2,3,4,5,6] and k = 1. Let ans = 5. In the binary search, no a_i's would be turned to 1e9 as 5/2 = 2 !< 2. First if condition fails as operation wasn't applied. In the second if condition, k==1 and max(a_1,..,a_n) = 12 > 5, hence it will return true.But, if we change 11 to 1e9, then d(5,6)= 2*min = 2*2 = 4 < 5? [<<<new_com>>>]
((946416, 946417)) <<===>> The division is not floored, $$$\frac{5}{2} = 2.5$$$, not $$$2$$$. [<<<new_com>>>]
((946417, 946418)) <<===>> Aha, I think I understand now. Thanks a lot! [<<<new_com>>>]
