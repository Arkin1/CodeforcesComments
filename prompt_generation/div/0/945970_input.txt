((-1, 945970)) <<===>> I used a slightly different approach to D that didn't require a seperate pass for each bit:  Create a weighted graph For each vertex AND together the weights of all its neighbouring edges. This tells you what bits can be set for that vertex. Call this the available value for the vertex. Now go through the vertexes in order. If a vertex is its own neighbour then that gives you its value. Otherwise, OR together values for each edge:    If the edge goes to a lower numbered vertex, include those bits that are required by the edge but are not included in the solution for the other vertex. This can be calculated as (Edge weight) AND NOT (Other vertex value) If the edge goes to a higher numbered vertex, include those bits that are required by the edge but are not available for the other vertex. This can be calculated as (Edge Weight) AND NOT (Other vertex available value)  This gives each vertex its smallest possible value subject to the values given to previous vertexes, so gives the lexically smallest possible sequence of values.See my solution  (link to problem D) I think one could create a similar solution without creating a graph by doing two passes through the data, which might be more efficient. [<<<new_com>>>]
((945970, 945975)) <<===>> My last comment is wrong. On the second pass one needs to go through the array values (vertexes) in order, and to know the final values of all lower numbered adjacent vertexes before calculating the value of current vertex, so this needs full adjacency information (i.e a graph). [<<<new_com>>>]
