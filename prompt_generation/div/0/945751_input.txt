((-1, 945751)) <<===>> You can also solve E using Divide and Conquer DP because of the square cost function (link to problem E)  [<<<new_com>>>]
((945751, 946223)) <<===>> can you elaborate on the divide and conquer dp?  [<<<new_com>>>]
((946223, 946247)) <<===>> The objective of the D&C was to calculate the minimum distance after a flight(assuming the flight just landed at some point), so you have a set of distances you got from dijkstra in $$$dp$$$_$$$old$$$, then you calculate post flight distance for $$$i$$$, aka $$$dp$$$_$$$new[i]$$$ as $$$min_j (dp$$$_$$$old[j] + (i-j)^2) $$$I divided this up into two parts$$$min_{j<i} (dp$$$_$$$old[j] + (i-j)^2)$$$$$$min_{j>i} (dp$$$_$$$old[j] + (i-j)^2)$$$ Both of these are what I solved using D&C DP, followed by more Dijkstra to calculate travel via roads [<<<new_com>>>]
((946247, 946267)) <<===>> nice get the divide and conquer now, using the optimal to cut up the array was cool wouldn't have thought of that [<<<new_com>>>]
((946247, 946373)) <<===>> Can you elaborate how to solve one of those partial minimums? I was able to do that only with some crazy math. [<<<new_com>>>]
((946373, 946378)) <<===>> Let $$$opt[i]$$$ be the index $$$j, j<i$$$ which gave the minimum value of $$$dp[j] + (i-j)^2$$$, then Divide and Conquer DP works iff $$$x < y$$$ implies that $$$opt[x] < opt[y]$$$, which you can see is the case here with some light maths. What you do is, if you want to calculate $$$dp[l]$$$ to $$$dp[r]$$$, let $$$mid$$$ be the middle point, you calculate $$$dp[mid]$$$ and $$$opt[mid]$$$ in $$$O(r-l)$$$, and once you calculate $$$opt[mid]$$$, it reduces the range you need to search for the rest of the elements, then you recursively do this calculate $$$dp[mid]$$$ and $$$opt[mid]$$$ for the segments that are left and right of $$$mid$$$. This was very brief but you can read more about Divide and Conquer DP here [<<<new_com>>>]
