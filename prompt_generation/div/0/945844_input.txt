((-1, 945844)) => <div class="ttypography"><p>D does not require any graph theory knowledge at all. </p><p>Initially, there are $$$30n$$$ unknown bits. </p><p>We can do a first pass over the queries to find all bits $$$p$$$ and $$$q$$$ such that $$$p \mid q = 0$$$, which means $$$p = q = 0$$$. These are the <strong>only</strong> bits that <em>must</em> be 0 in order to satisfy the statements (you can hypothetically set all remaining bits to 1 and this will satisfy the statements, but likely will not be lexicographically least).</p><p>Then we can do a second pass over the queries to find all bits $$$p$$$ such that $$$p \mid 0 = 1$$$ or $$$p \mid p = 1$$$, which means $$$p = 1$$$. The former can arise due to forced 0 bits from the first pass, while the latter can arise from statements where $$$i = j$$$. These are the <strong>only</strong> bits that <em>must</em> be 1 in order to satisfy the constraints (though you can't simply turn all remaining bits into 0 this time, since our remaining equations have the form $$$p \mid q = 1$$$).</p><p>With the fixed bits out of the way, we can greedily clear all non-fixed bits of $$$a_1$$$ to 0. If any of these bits were involved in an equation of the form $$$p \mid q = 1$$$, then the other bit in the equation becomes fixed to 1 to satisfy it. We can then repeat for $$$a_2$$$ and so on. </p><p>Runtime: $$$O(m + n)$$$, with a constant 30 iterations for everything. </p><p>My Submission:  <submission link>  (I checked for $$$i = j$$$ and $$$p \mid q = 0$$$ while reading the statements)</p></div>
((945844, 945858)) => <div class="ttypography"><div class="spoiler"><b class="spoiler-title">Spoiler</b><div class="spoiler-content" style="display: none;"><p><img alt=" " src="/predownloaded/d8/47/d847ad30ff9d6d31349b1e070f45d568f7a63880.jpg" style="max-width: 100.0%;max-height: 100.0%;" /></p></div></div></div>
